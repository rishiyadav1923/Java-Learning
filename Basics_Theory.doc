PAGE 1 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Introduction to Java

JAVA was developed by James Gosling at Sun Microsystems Inc in the year 1995, later acquired by Oracle Corporation. It is a simple programming language. Java makes writing, compiling, and debugging programming easy. It helps to create reusable code and modular programs. Java is a class-based, object-oriented programming language and is designed to have as few implementation dependencies as possible. A general-purpose programming language made for developers to write once run anywhere that is compiled Java code can run on all platforms that support Java. Java applications are compiled to byte code that can run on any Java Virtual Machine. The syntax of Java is similar to c/c++.
History: Java’s history is very interesting. It is a programming language created in 1991. James Gosling, Mike Sheridan, and Patrick Naughton, a team of Sun engineers known as the Green team initiated the Java language in 1991. Sun Microsystems released its first public implementation in 1996 as Java 1.0. It provides no-cost -run-times on popular platforms. Java1.0 compiler was re-written in Java by Arthur Van Hoff to strictly comply with its specifications. With the arrival of Java 2, new versions had multiple configurations built for different types of platforms.
In 1997, Sun Microsystems approached the ISO standards body and later formalized Java, but it soon withdrew from the process. At one time, Sun made most of its Java implementations available without charge, despite their proprietary software status. Sun generated revenue from Java through the selling of licenses for specialized products such as the Java Enterprise System.
On November 13, 2006, Sun released much of its Java virtual machine as free, open-source software. On May 8, 2007, Sun finished the process, making all of its JVM’s core code available under open-source distribution terms.
The principles for creating java were simple, robust, secured, high performance, portable, multi-threaded, interpreted, dynamic, etc. In 1995 Java was developed by James Gosling, who is known as the Father of Java. Currently, Java is used in mobile devices, internet programming, games, e-business, etc.
Java programming language is named JAVA. Why?
After the name OAK, the team decided to give a new name to it and the suggested words were Silk, Jolt, revolutionary, DNA, dynamic, etc. These all names were easy to spell and fun to say, but they all wanted the name to reflect the essence of technology. In accordance with James Gosling, Java the among the top names along with Silk, and since java was a unique name so most of them preferred it.
Java is the name of an island in Indonesia where the first coffee(named java coffee) was produced. And this name was chosen by James Gosling while having coffee near his office. Note that Java is just a name, not an acronym.

Java Terminology

Before learning Java, one must be familiar with these common terms of Java.
1.  Java Virtual Machine(JVM):  This is generally referred to as JVM. There are three execution phases of a program. They are written, compile and run the program.
Writing a program is done by a java programmer like you and me.
The compilation is done by the JAVAC compiler which is a primary Java compiler included in the Java development kit (JDK). It takes the Java program as input and generates bytecode as output.
In the Running phase of a program, JVM executes the bytecode generated by the compiler.
Now, we understood that the function of Java Virtual Machine is to execute the bytecode produced by the compiler. Every Operating System has a different JVM but the output they produce after the execution of bytecode is the same across all the operating systems. This is why Java is known as a platform-independent language.
2. Bytecode in the Development process:  As discussed, the Javac compiler of JDK compiles the java source code into bytecode so that it can be executed by JVM. It is saved as .class file by the compiler. To view the bytecode, a disassembler like javap can be used.
3. Java Development Kit(JDK): While we were using the term JDK when we learn about bytecode and JVM. So, as the name suggests, it is a complete Java development kit that includes everything including compiler, Java Runtime Environment (JRE), java debuggers, java docs, etc. For the program to execute in java, we need to install JDK on our computer in order to create, compile and run the java program.
4. Java Runtime Environment (JRE): JDK includes JRE. JRE installation on our computers allows the java program to run, however, we cannot compile it. JRE includes a browser, JVM, applet supports, and plugins. For running the java program, a computer needs JRE.
5. Garbage Collector: In Java, programmers can’t delete the objects. To delete or recollect that memory JVM has a program called Garbage Collector. Garbage Collectors can recollect the objects that are not referenced. So Java makes the life of a programmer easy by handling memory management. However, programmers should be careful about their code whether they are using objects that have been used for a long time. Because Garbage cannot recover the memory of objects being referenced.
6. ClassPath: The classpath is the file path where the java runtime and Java compiler look for .class files to load. By default, JDK provides many libraries. If you want to include external libraries they should be added to the classpath.

Primary/Main Features of Java
1. Platform Independent:  Compiler converts source code to bytecode and then the JVM executes the bytecode generated by the compiler. This bytecode can run on any platform be it Windows, Linux, or macOS which means if we compile a program on Windows, then we can run it on Linux and vice versa. Each operating system has a different JVM, but the output produced by all the OS is the same after the execution of bytecode. That is why we call java a platform-independent language.
2. Object-Oriented Programming Language:  Organizing the program in the terms of collection of objects is a way of object-oriented programming, each of which represents an instance of the class.

The four main concepts of Object-Oriented programming are:

Abstraction
Encapsulation
Inheritance
Polymorphism

3. Simple:  Java is one of the simple languages as it does not have complex features like pointers, operator overloading, multiple inheritances, and Explicit memory allocation. 
4. Robust:  Java language is robust which means reliable. It is developed in such a way that it puts a lot of effort into checking errors as early as possible, that is why the java compiler is able to detect even those errors that are not easy to detect by another programming language. The main features of java that make it robust are garbage collection, Exception Handling, and memory allocation.
5. Secure:  In java, we don’t have pointers, so we cannot access out-of-bound arrays i.e it shows ArrayIndexOutOfBound Exception if we try to do so. That’s why several security flaws like stack corruption or buffer overflow are impossible to exploit in Java. Also java programs run in an environment that is independent of the os(operating system) environment which makes java programs more secure .
6. Distributed:  We can create distributed applications using the java programming language. Remote Method Invocation and Enterprise Java Beans are used for creating distributed applications in java. The java programs can be easily distributed on one or more systems that are connected to each other through an internet connection.
7. Multithreading:  Java supports multithreading. It is a Java feature that allows concurrent execution of two or more parts of a program for maximum utilization of the CPU.
8. Portable:  As we know, java code written on one machine can be run on another machine. The platform-independent feature of java in which its platform-independent bytecode can be taken to any platform for execution makes java portable.
9. High Performance: Java architecture is defined in such a way that it reduces overhead during the runtime and at some time java uses Just In Time (JIT) compiler where the compiler compiles code on-demand basics where it only compiles those methods that are called making applications to execute faster.
10. Dynamic flexibility: Java being completely object-oriented gives us the flexibility to add classes,  new methods to existing classes and even create new classes through sub-classes. Java even supports functions written in other languages such as C, C++ which are referred to as native methods.
11. Sandbox Execution: Java programs run in a separate space that allows user to execute their applications without affecting the underlying system with help of a bytecode verifier. Bytecode verifier also provides additional security as its role is to check the code for any violation of access.
12. Write Once Run Anywhere: As discussed above java application generates a ‘.class’ file which corresponds to our applications(program) but contains code in binary format. It provides ease t architecture-neutral ease as bytecode is not dependent on any machine architecture. It is the primary reason java is used in the enterprising IT industry globally worldwide.
13. Power of compilation and interpretation: Most languages are designed with purpose either they are compiled language or they are interpreted language. But java integrates arising enormous power as Java compiler compiles the source code to bytecode and JVM  executes this bytecode to machine OS-dependent executable code.

Example


// Importing classes from packages
import java.io.*;
 
// Main class
public class GFG {
 
    // Main driver method
    public static void main(String[] args)
    {
 
        // Print statement
        System.out.println("Welcome to GeeksforGeeks");
    }
}
Output
Welcome to GeeksforGeeks
Explanation:

1.  Comments: Comments are used for explaining code and are used in a similar manner in Java or C or C++. Compilers ignore the comment entries and do not execute them. Comments can be of a single line or multiple lines.
Single line Comments:
Syntax:

// Single line comment
Multi-line comments:
Syntax:
/* Multi line comments*/

2.  import java.io.*: This means all the classes of io package can be imported. Java io package provides a set of input and output streams for reading and writing data to files or other input or output sources.
3.  class: The class contains the data and methods to be used in the program. Methods define the behavior of the class. Class GFG has only one method Main in JAVA.
4.  static void Main(): static keyword tells us that this method is accessible without instantiating the class. 
5.  void: keywords tell that this method will not return anything. The main() method is the entry point of our application.
6.  System.in: This is the standard input stream that is used to read characters from the keyboard or any other standard input device.
7.  System.out: This is the standard output stream that is used to produce the result of a program on an output device like the computer screen.
8.  println(): This method in Java is also used to display text on the console. It prints the text on the console and the cursor moves to the start of the next line at the console. The next printing takes place from the next line.
9.  String []args: This is the argument passed to the main function which is an array of strings with the array name args. One can choose their own flexible name but this name is used by many developers.

Everything in java , is represented in Class as an object including the main function.

PAGE - 2 ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

These three programming languages are the most popular among coders in terms of competitive coding and programming. C++ of today in its efficiency, speed, and memory makes it widely popular among coders. Java is platform-independent. It continues to add considerable value to the world of software development. Python requires less typing and provides new libraries, fast prototyping, and several other new features. Let’s look at the comparison between these popular coding languages.

C++ Vs Java:

    TOPIC	                                        C++	                                                Java
Memory Management	                    Use of pointers, structures, union	                No use of pointers. Supports references, thread and interfaces.
Libraries	                Comparatively available with low-level functionalities	        Wide range of classes for various high-level services
Multiple Inheritance	            Provide both single and multiple inheritance.	        Multiple inheritances is partially done through interfaces
Operator Overloading	                Supports operator overloading	                    It doesn’t support this feature
Program Handling	            Functions and variables can reside outside classes.	        Functions and variables reside only in classes, packages are used.
Portability	                Platform dependent, must be recompiled for different platform	Platform independent, byte code generated works on every OS.
Thread Support	                No built-in support for threads, depends on libraries.	    It has built-in thread support.

Datatype | Python Vs Java:

Components can be developed in Java and combined to form applications in Python. Let’s see some of the differences between these two popular languages:


    TOPIC	                                                    Java	                                                                                                                                 Python
Compilation process	                    Java is both compiled and interpreted language, which is first compiled and then interpreted into a byte code.	                                Python is an interpreted programming language
Code Length	                            Longer lines of code as compared to python.	                                                                                                    3-5 times shorter than equivalent Java programs.
Syntax Complexity	                    Define particular block by curly braces, end statements by ;	                                                                                No need of semi colons and curly braces, uses indentation
Ease of typing	                        Strongly typed, need to define the exact datatype of variables	                                                                                Dynamic, no need to define the exact datatype of variables.
Speed of execution	                    Java is much faster than python in terms of speed.	                                                                                            Expected to run slower than Java programs
Multiple Inheritance	                Multiple inheritance is partially done through interfaces	                                                                                    Provide both single and multiple inheritance

You can choose any language you want i.e. the one you are comfortable working with. Technically it depends upon the job you want to accomplish. These 3 languages form the set of most popular languages among college graduates’ coders and developers.
I would suggest you stick with one language and achieve perfection in that. These languages may help you to achieve the level of coding you want to reach. I hope one day a coder reading this article may get inspired to develop a language similar to 
these and make a breakthrough for coders all around the world.

PAGE 3 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

The complete History of Java Programming Language

Java is an Object-Oriented programming language developed by James Gosling in the early 1990s. The team initiated this project to develop a language for digital devices such as set-top boxes, television, etc. Originally C++ was considered to be used in the project 
but the idea was rejected for several reasons(For instance C++ required more memory). Gosling endeavoured to alter and expand C++ however before long surrendered that for making another stage called Green. James Gosling and his team called their project “Greentalk” 
and its file extension was .gt and later became to known as “OAK”. Why “Oak”? The name Oak was used by Gosling after an oak tree that remained outside his office. Also, Oak is an image of solidarity and picked as a national tree of numerous nations like the U.S.A., 
France, Germany, Romania, etc. But they had to later rename it as “JAVA” as it was already a trademark by Oak Technologies. “JAVA” Gosling and his team did a brainstorm session and after the session, they came up with several names such as JAVA, DNA, SILK, RUBY, etc. 
Java name was decided after much discussion since it was so unique. The name Java originates from a sort of espresso bean, Java. Gosling came up with this name while having a coffee near his office. Java was created on the principles like Robust, Portable, Platform 
Independent, High Performance, Multithread, etc. and was called one of the Ten Best Products of 1995 by the TIME MAGAZINE. Currently, Java is used in internet programming, mobile devices, games, e-business solutions, etc. The Java language has experienced a few changes 
since JDK 1.0 just as various augmentations of classes and packages to the standard library. In Addition to the language changes, considerably more sensational changes have been made to the Java Class Library throughout the years, which has developed from a couple of 
hundred classes in JDK 1.0 to more than three thousand in J2SE 5.  History of various Java versions:

    Version	                    Release Date / Major Changes
    JDK Beta	                    1995

    JDK 1.0	                    January 1996
                                The Very first version was released on January 23, 1996. The principal stable variant, JDK 1.0.2, is called Java 1.

    JDK 1.1	                    February 1997
                                Was released on February 19, 1997. There were many additions in JDK 1.1 as compared to version 1.0 such as
                                A broad retooling of the AWT occasion show
                                Inner classes added to the language
                                JavaBeans
                                JDBC
                                RMI

    J2SE 1.2	                December 1998
                                “Play area” was the codename which was given to this form and was released on 8th December 1998. Its real expansion included: strictfp keyword
                                the Swing graphical API was coordinated into the centre classes
                                Sun’s JVM was outfitted with a JIT compiler out of the blue
                                Java module
                                Java IDL, an IDL usage for CORBA interoperability
                                Collections system

    J2SE 1.3	                May 2000
                                Codename- “KESTREL” Release Date- 8th May 2000 Additions:
                                HotSpot JVM included
                                Java Naming and Directory Interface
                                JPDA
                                JavaSound
                                Synthetic proxy classes

    J2SE 1.4	                February 2002
                                Codename- “Merlin” Release Date- 6th February 2002 Additions: Library improvements
                                Regular expressions modelled after Perl regular expressions
                                The image I/O API for reading and writing images in formats like JPEG and PNG
                                Integrated XML parser and XSLT processor (JAXP) (specified in JSR 5 and JSR 63)
                                Preferences API (java.util.prefs)
                                Public Support and security updates for this version ended in October 2008.

    J2SE 5.0	                September 2004
                                Codename- “Tiger” Release Date- “30th September 2004” Originally numbered as 1.5 which is still used as its internal version. Added several new language features such as:
                                for-each loop
                                Generics
                                Autoboxing
                                Var-args

    JAVA SE 6	                December 2006
                                Codename- “Mustang” Released Date- 11th December 2006 Packaged with a database supervisor and encourages the utilization of scripting languages with the JVM. Replaced the name J2SE with java SE and dropped the .0 from the version number. Additions:
                                Upgrade of JAXB to version 2.0: Including integration of a StAX parser.
                                Support for pluggable annotations (JSR 269).

    JDBC 4.0                    support (JSR 221)

    JAVA SE 7	                July 2011
                                Codename- “Dolphin” Release Date- 7th July 2011 Added small language changes including strings in the switch. The JVM was extended with support for dynamic languages. Additions:
                                Compressed 64-bit pointers.
                                Binary Integer Literals.
                                Upstream updates to XML and Unicode.

    JAVA SE 8	                March 2014
                                Released Date- 18th March 2014 Language level support for lambda expressions and default methods and a new date and time API inspired by Joda Time.

    JAVA SE 9	                September 2017
                                Release Date: 21st September 2017 Project Jigsaw: designing and implementing a standard, a module system for the Java SE platform, and to apply that system to the platform itself and the JDK.

    JAVA SE 10	                March 2018
                                Released Date- 20th March Addition:
                                Additional Unicode language-tag extensions
                                Root certificates
                                Thread-local handshakes
                                Heap allocation on alternative memory devices
                                Remove the native-header generation tool – javah.
                                Consolidate the JDK forest into a single repository.

    JAVA SE 11	                September 2018
                                Released Date- 25th September, 2018 Additions-
                                Dynamic class-file constants
                                Epsilon: a no-op garbage collector
                                The local-variable syntax for lambda parameters
                                Low-overhead heap profiling
                                HTTP client (standard)
                                Transport Layer Security (TLS) 1.3
                                Flight recorder

    JAVA SE 12	                March 2019
                                Released Date- 19th March 2019 Additions-
                                Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)
                                Microbenchmark Suite
                                Switch Expressions (Preview)
                                JVM Constants API
                                One AArch64 Port, Not Two
                                Default CDS Archives


PAGE 4 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

JDK in Java :- 

The Java Development Kit (JDK) is a cross-platformed software development environment that offers a collection of tools and libraries necessary for developing Java-based software applications and applets. It is a core package used in Java, along with the JVM (Java Virtual Machine) and the JRE (Java Runtime Environment). 
Beginners often get confused with JRE and JDK, if you are only interested in running Java programs on your machine then you can easily do it using Java Runtime Environment. However, if you would like to develop a Java-based software application then along with JRE you may need some additional necessary tools, which is called JDK.

JDK = JRE + Development Tools
JRE = JVM + Library Classes


JAVA Development Kit (JDK)

The Java Development Kit  is an implementation of  one of the Java Platform:
Standard Edition (Java SE),
Java Enterprise Edition (Java EE),
Micro Edition (Java ME),
Contents of JDK
The JDK has a private Java Virtual Machine (JVM) and a few other resources necessary for the development of a Java Application. 


JDK contains:

Java Runtime Environment (JRE),
An interpreter/loader (Java),
A compiler (javac),
An archiver (jar) and many more.
The  Java Runtime Environment in JDK is usually called Private Runtime because it is separated from the regular JRE and has extra content. The Private Runtime in JDK contains a JVM and all the class libraries present in the production environment, as well as additional libraries useful to developers, e.g, internationalization libraries and the IDL libraries.

Most Popular JDKs:
Oracle JDK: the most popular JDK and the main distributor of Java11,
OpenJDK: Ready for use: JDK 15, JDK 14, and JMC,
Azul Systems Zing: efficient and low latency JDK for Linux os,
Azul Systems: based Zulu brand for Linux, Windows, Mac OS X,
IBM J9 JDK: for AIX, Linux, Windows, and many other OS,
Amazon Corretto: the newest option with the no-cost build of OpenJDK and long-term support.
Set-Up:
Setting up JDK in your development environment is super easy, just follow the below simple steps. 

Installation of JDK

Go to this Oracle’s official Download Page through this link
Select the latest JDK version and click Download and add it to your classpath.
Just check the JDK software is installed or not on your computer at the correct location, for example, at C:\Program Files\Java\jdk11.0.9.
Set JAVA_HOME for Windows:

Right-click My Computer and select Properties.
Go to the Advanced tab and select Environment Variables, and then edit JAVA_HOME to point to the exact location where your JDK software is stored, for example, C:\Program Files\Java\jdk11.0.9 is the default location in windows.
Java maintains backward compatibility, so don’t worry just download the latest release and you will get all the old and many new features. After Installing the JDK and JRE adds the java command to your command line. You can verify this through the command prompt by the java -version command. In some cases, you need to restart your system after installing the JDK.


JDK Version

Compile and Run Java Code using JDK:
You can use the JDK compiler to convert your Java text file into an executable program. Your Java text segment is converted into bytecode after compilation which carries the .class extension.

First, create a Java text file and save it using a name. Here we are saving the file as Hello.java.


class Hello{
    public static void main (String[] args) {
        System.out.println("Hello Geek!");
    }
}

After that just simply use the javac command, which is used for the compilation purpose in Java. Please don’t forget to provide the full path of your java text file to the command line else you will get an error as “The system cannot find the path specified”, 
Your command should be similar to the given below example where Hello is the file name and the full path to the file is specified before the file name. The path and javac.exe should be inside the quotes.

“C:\Program Files\Java\jdk-11.0.9\bin\javac.exe” Hello.java

You can notice now that the Hello.class file is being created in the same directory as Hello.java. Now you can run your code by simply using the java Hello command, which will give you the desired result according to your code. Please remember that you don’t have to include the .class to run your code.

C:\Users\Pinaki\Documents>java hello_world
(Output:) Hello Geek!

The Jar component:
JDK contains many useful tools and among them, the most popular after javac is the jar tool. The jar file is nothing but a full pack of Java classes. After creating the .class files, you can put them together in a .jar, which compresses and structures them in a predictable fashion. Now, let’s convert our Hello.class to a jar file.
Before proceeding, please note that you should be in the same directory where the Hello.java file was saved. Now type the command given below in the command line.

Creating a .jar file

C:\Users\Pinaki\Documents>”c:\Program Files\Java\jdk-11.0.9\bin\jar.exe” –create –file Hello.jar Hello.class

Now you can notice that Hello.jar file had been created in the same directory using Hello.class file and jar.exe. You can use the jar file by adding it to your classpath and executing the program inside it. Here the -cp stands for classpath which helps to add the jar to the same classpath.

Executing the .jar file

java -cp hello_world.jar hello_world

Important Components of JDK
Below there is a comprehensive list of mostly used components of Jdk which are very useful during the development of a java application.

Component               Use

javac                   Java compiler converts source code into Java bytecode
java                    The loader of the java apps.
javap                   Class file disassembler,
javadoc                 Documentation generator,
jar                     Java Archiver helps manage JAR files.
appletviewer            Debugging of Java applets without a web browser,
xjc                     Accepts an XML schema and generates Java classes,
apt                     Annotation-processing tool,
jdb                     Debugger,
jmc                     Java Mission Control,
JConsole                Monitoring and Management Console,
pack200                 JAR compression tool,
extcheck                Utility tool to detects JAR file conflicts,
idlj                    IDL-to-Java compiler,
keytool                 The keystore manipulating tool,
jstatd                  jstat daemon (experimental)
jstat                   JVM statistics monitoring tool
jshell                  jshell introduced in java 9.
jstack                  Prints Java stack traces(experimental)
jrunscript              Java command-line script shell.
jhat                    Java Heap Analysis Tool (experimental)
jpackage                Generate self-contained application bundles.
javaws                  Web Start launcher for JNLP applications,
javah                   C header and stub generator,
jarsigner               jar signing and verification tool
jinfo                   configuration information(experimental)
javafxpackager          Package and sign JavaFX applications

PAGE 5 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

How JVM Works – JVM Architecture?

JVM(Java Virtual Machine) acts as a run-time engine to run Java applications. JVM is the one that actually calls the main method present in a java code. JVM is a part of JRE(Java Runtime Environment).
Java applications are called WORA (Write Once Run Anywhere). This means a programmer can develop Java code on one system and can expect it to run on any other Java-enabled system without any adjustment. This is all possible because of JVM.
When we compile a .java file, .class files(contains byte-code) with the same class names present in .java file are generated by the Java compiler. This .class file goes into various steps when we run it. These steps together describe the whole JVM. 

JVM Language Classes ---> Class Loader <----> {JVM Menory [Method Area] [Heap] [JVM Language Stacks] [PC Registers] [Native Method Stacks]} <----> {Execution Engine} <----> {Native Method Interface} <----> {Native Method Libraries}
                                        ^


Class Loader Subsystem

It is mainly responsible for three activities.

Loading
Linking
Initialization
Loading: The Class loader reads the “.class” file, generate the corresponding binary data and save it in the method area. For each “.class” file, JVM stores the following information in the method area. 

1. The fully qualified name of the loaded class and its immediate parent class.
2. Whether the “.class” file is related to Class or Interface or Enum.
3. Modifier, Variables and Method information etc.
After loading the “.class” file, JVM creates an object of type Class to represent this file in the heap memory. Please note that this object is of type Class predefined in java.lang package. 
These Class object can be used by the programmer for getting class level information like the name of the class, parent name, methods and variable information etc. To get this object reference we can use getClass() method of Object class.


// A Java program to demonstrate working
// of a Class type object created by JVM
// to represent .class file in memory.
import java.lang.reflect.Field;
import java.lang.reflect.Method;

// Java code to demonstrate use
// of Class object created by JVM
public class Test {
    public static void main(String[] args)
    {
        Student s1 = new Student();

        // Getting hold of Class
        // object created by JVM.
        Class c1 = s1.getClass();

        // Printing type of object using c1.
        System.out.println(c1.getName());

        // getting all methods in an array
        Method m[] = c1.getDeclaredMethods();
        for (Method method : m)
            System.out.println(method.getName());

        // getting all fields in an array
        Field f[] = c1.getDeclaredFields();
        for (Field field : f)
            System.out.println(field.getName());
    }
}

// A sample class whose information
// is fetched above using its Class object.
class Student {
    private String name;
    private int roll_No;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getRoll_no() { return roll_No; }
    public void setRoll_no(int roll_no)
    {
        this.roll_No = roll_no;
    }
}
Output
Student
getName
setName
getRoll_no
setRoll_no
name
roll_No

Note: For every loaded “.class” file, only one object of the class is created.


Student s2 = new Student();
// c2 will point to same object where 
// c1 is pointing
Class c2 = s2.getClass();
System.out.println(c1==c2); // true
Linking: Performs verification, preparation, and (optionally) resolution. 
 

Verification: It ensures the correctness of the .class file i.e. it checks whether this file is properly formatted and generated by a valid compiler or not. If verification fails, we get run-time exception java.lang.VerifyError. 
              This activity is done by the component ByteCodeVerifier. Once this activity is completed then the class file is ready for compilation.
Preparation: JVM allocates memory for class static variables and initializing the memory to default values. 
Resolution: It is the process of replacing symbolic references from the type with direct references. It is done by searching into the method area to locate the referenced entity.
Initialization: In this phase, all static variables are assigned with their values defined in the code and static block(if any). This is executed from top to bottom in a class and from parent to child in the class hierarchy. 

In general, there are three class loaders : 
 

Bootstrap class loader: Every JVM implementation must have a bootstrap class loader, capable of loading trusted classes. It loads core java API classes present in the “JAVA_HOME/jre/lib” directory. This path is popularly known as the bootstrap path. It is implemented in native languages like C, C++.
Extension class loader: It is a child of the bootstrap class loader. It loads the classes present in the extensions directories “JAVA_HOME/jre/lib/ext”(Extension path) or any other directory specified by the java.ext.dirs system property. It is implemented in java by the sun.misc.Launcher$ExtClassLoader class.
System/Application class loader: It is a child of the extension class loader. It is responsible to load classes from the application classpath. It internally uses Environment Variable which mapped to java.class.path. It is also implemented in Java by the sun.misc.Launcher$AppClassLoader class.

// Java code to demonstrate Class Loader subsystem
public class Test {
    public static void main(String[] args)
    {
        // String class is loaded by bootstrap loader, and
        // bootstrap loader is not Java object, hence null
        System.out.println(String.class.getClassLoader());
 
        // Test class is loaded by Application loader
        System.out.println(Test.class.getClassLoader());
    }
}

Output
null
jdk.internal.loader.ClassLoaders$AppClassLoader@8bcc55f
Note: JVM follows the Delegation-Hierarchy principle to load classes. System class loader delegate load request to extension class loader and extension class loader delegate request to the bootstrap class loader. 
If a class found in the boot-strap path, the class is loaded otherwise request again transfers to the extension class loader and then to the system class loader. At last, if the system class loader fails to load class, 
then we get run-time exception java.lang.ClassNotFoundException.

            {Bootstrap Class Loader} ------> {Find Class} --------> Class is Loaded By Bootstrap Class Loader
              ^                |
Load Class    |                |    Load Class
              |                |
            {Extension Class Loader} ------> {Find Class} ---------> Class is Loaded by Extension Class Loader
              ^                |
Load Class    |                |    Load Class
              |                |
            {Application Class Loader} <------{Request to Load a Class}

JVM Memory

Method area: In the method area, all class level information like class name, immediate parent class name, methods and variables information etc. are stored, including static variables. There is only one method area per JVM, and it is a shared resource. From java 8, static variables are now stored in Heap area.
Heap area: Information of all objects is stored in the heap area. There is also one Heap Area per JVM. It is also a shared resource.
Stack area: For every thread, JVM creates one run-time stack which is stored here. Every block of this stack is called activation record/stack frame which stores methods calls. All local variables of that method are stored in their corresponding frame. After a thread terminates, its run-time stack will be destroyed by JVM. It is not a shared resource.
PC Registers: Store address of current execution instruction of a thread. Obviously, each thread has separate PC Registers.
Native method stacks: For every thread, a separate native stack is created. It stores native method information. 
jvm2

{ {Method Area[Class Data]}         {Heap Area[Object Data]}        {Stack Memory[Runtime Stacks]}      {PC Registers}      {Native Method Stacks} }
                    |                               |                                    |
                    |                               |                                    |
                    |                               |                                    |
              Static Method                 Instance Variables                Method Calls Local Variables
              Static Variable
              Static reference

Execution Engine

Execution engine executes the “.class” (bytecode). It reads the byte-code line by line, uses data and information present in various memory area and executes instructions. It can be classified into three parts:

Interpreter: It interprets the bytecode line by line and then executes. The disadvantage here is that when one method is called multiple times, every time interpretation is required.
Just-In-Time Compiler(JIT) : It is used to increase the efficiency of an interpreter. It compiles the entire bytecode and changes it to native code so whenever the interpreter sees repeated method calls, JIT provides direct native code for that part so re-interpretation is not required, thus efficiency is improved.
Garbage Collector: It destroys un-referenced objects. For more on Garbage Collector, refer Garbage Collector.
Java Native Interface (JNI) :

It is an interface that interacts with the Native Method Libraries and provides the native libraries(C, C++) required for the execution. It enables JVM to call C/C++ libraries and to be called by C/C++ libraries which may be specific to hardware.

Native Method Libraries :

It is a collection of the Native Libraries(C, C++) which are required by the Execution Engine.

PAGE 6 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DIFFERENCE BETWEEN JDK, JVM & JRE :-

Java Development Kit (JDK) is a software development environment used for developing Java applications and applets. It includes the Java Runtime Environment (JRE), an interpreter/loader (Java), a compiler (javac), an archiver (jar), a documentation generator (Javadoc), and other tools needed in Java development. 
Now we need an environment to make a run of our program. Henceforth, JRE stands for “Java Runtime Environment” and may also be written as “Java RTE.” The Java Runtime Environment provides the minimum requirements for executing a Java application; it consists of the Java Virtual Machine (JVM), core classes, and supporting files. 
Now let us discuss JVM, which stands out for java virtual machines. It is as follows:

A specification where the working of Java Virtual Machine is specified. But implementation provider is independent to choose the algorithm. Its implementation has been provided by Sun and other companies.
An implementation is a computer program that meets the requirements of the JVM specification.
Runtime Instance Whenever you write a java command on the command prompt to run the java class, an instance of JVM is created.
Before proceeding to the differences between JDK, JRE, and JVM, let us discuss them in brief first and interrelate them with the image below proposed.




Don’t get confused as we are going to discuss all of them one by one.

1. JDK (Java Development Kit) is a Kit that provides the environment to develop and execute(run) the Java program. JDK is a kit(or package) that includes two things
Development Tools(to provide an environment to develop your java programs)
JRE (to execute your java program).

2. JRE (Java Runtime Environment) is an installation package that provides an environment to only run(not develop) the java program(or application)onto your machine. 
   JRE is only used by those who only want to run Java programs that are end-users of your system.

3. JVM (Java Virtual Machine) is a very important part of both JDK and JRE because it is contained or inbuilt in both. Whatever Java program you run using JRE or JDK 
goes into JVM and JVM is responsible for executing the java program line by line, hence it is also known as an interpreter.

Now let us discuss the components of JRE in order to understand its importance of it and perceive how it actually works. For this let us discuss components.

The components of JRE are as follows:

Deployment technologies :- including deployment, Java Web Start, and Java Plug-in.
User interface toolkits :- including Abstract Window Toolkit (AWT), Swing, Java 2D, Accessibility, Image I/O, Print Service, Sound, drag, and drop (DnD), and input methods.
Integration libraries :- including Interface Definition Language (IDL), Java Database Connectivity (JDBC), Java Naming and Directory Interface (JNDI), Remote Method Invocation (RMI), Remote Method Invocation Over Internet Inter-Orb Protocol (RMI-IIOP), and scripting.
Other base libraries :- including international support, input/output (I/O), extension mechanism, Beans, Java Management Extensions (JMX), Java Native Interface (JNI), Math, Networking, Override Mechanism, Security, Serialization, and Java for XML Processing (XML JAXP).
Lang and util base libraries :- including lang and util, management, versioning, zip, instrument, reflection, Collections, Concurrency Utilities, Java Archive (JAR), Logging, Preferences API, Ref Objects, and Regular Expressions.
Java Virtual Machine (JVM) :- including Java HotSpot Client and Server Virtual Machines.
After having an adequate understanding of the components, now let us discuss the working of JDK. In order to understand how JDK works, let us consider an illustration below as follows:

Illustration:


Consider a java source file saved as ‘Example.java’. The file is compiled into a set of Byte Code that is stored in a “.class” file. Here it will be “Example.class“. 

    Complier -----SAVE-----> {Example.java} ----javac----> {Example.class}

Note: From above, media operation computing during the compile time can be interpreted.

The following actions occur at runtime as listed below:

Class Loader
Byte Code Verifier
Interpreter
    Execute the Byte Code
    Make appropriate calls to the underlying hardware

Now let us discuss in brief how JVM works out. It is as follows:

JVM becomes an instance of JRE at the runtime of a Java program. It is widely known as a runtime interpreter.JVM largely helps in the abstraction of inner implementation from the programmers who make use of libraries for their programs from JDK. 
It is mainly responsible for three activities. 

Loading
Linking
Initialization
Similarly, now let us discuss the working of JRE which is as follows:

JVM(Java Virtual Machine) acts as a run-time engine to run Java applications. JVM is the one that actually calls the main method present in a java code. JVM is a part of JRE(Java Runtime Environment).
Java applications are called WORA (Write Once Run Anywhere). This means a programmer can develop Java code on one system and can expect it to run on any other Java-enabled system without any adjustments. This is all possible because of JVM.
When we compile a .java file, .class files(contains byte-code) with the same class names present in .java file are generated by the Java compiler. This .class file goes into various steps when we run it. These steps together describe the whole JVM.

JVM Language Classes ---> Class Loader <----> {JVM Menory [Method Area] [Heap] [JVM Language Stacks] [PC Registers] [Native Method Stacks]} <----> {Execution Engine} <----> {Native Method Interface} <----> {Native Method Libraries}

PAGE 7 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

JUST IN TIME COMPILER (JIT) :-

The Just-In-Time (JIT) compiler is an essential part of the JRE i.e. Java Runtime Environment, that is responsible for performance optimization of java based applications at run time. The compiler is one of the key aspects in deciding the performance of an application for both parties i.e. the end-user and the application developer.

Java JIT Compiler : General Overview

Bytecode is one of the most important features of java that aids in cross-platform execution. The way of converting bytecode to native machine language for execution has a huge impact on its speed of it. 
These Bytecode have to be interpreted or compiled to proper machine instructions depending on the instruction set architecture. Moreover, these can be directly executed if the instruction architecture is bytecode based. 
Interpreting the bytecode affects the speed of execution. In order to improve performance, JIT compilers interact with the Java Virtual Machine (JVM) at run time and compile suitable bytecode sequences into native machine code. 
While using a JIT compiler, the hardware is able to execute the native code, as compared to having the JVM interpret the same sequence of bytecode repeatedly and incurring overhead for the translation process. This subsequently 
leads to performance gains in the execution speed, unless the compiled methods are executed less frequently. The JIT compiler is able to perform certain simple optimizations while compiling a series of bytecode to native machine language. 
Some of these optimizations performed by JIT compilers are data analysis, reduction of memory accesses by register allocation, translation from stack operations to register operations, elimination of common sub-expressions, etc. 
The greater is the degree of optimization done, the more time a JIT compiler spends in the execution stage. Therefore it cannot afford to do all the optimizations that a static compiler is capable of, because of the extra overhead 
added to the execution time and moreover it’s view of the program is also restricted. 

Working of JIT Compiler

    |-------------- At Compile Time ---------------------|                 |-------------------- At Run Time ------------------------|
    SourceCode.java --------> Compiler ---------> ByteCode --------------->    JIT Compiler ----------------> Native Machine Code

Java follows an object-oriented approach, as a result, it consists of classes. These constitute bytecode that is platform neutral and are executed by the JVM across diversified architectures.

At run time, the JVM loads the class files, the semantics of each are determined, and appropriate computations are performed. The additional processor and memory usage during interpretation make a Java application perform slowly as compared to a native application.
The JIT compiler aids in improving the performance of Java programs by compiling bytecode into native machine code at run time.
The JIT compiler is enabled throughout, while it gets activated when a method is invoked. For a compiled method, the JVM directly calls the compiled code, instead of interpreting it. Theoretically speaking, If compiling did not require any processor time or memory usage, the speed of a native compiler and that of a Java compiler would have been the same.
JIT compilation requires processor time and memory usage. When the java virtual machine first starts up, thousands of methods are invoked. Compiling all these methods can significantly affect startup time, even if the end result is a very good performance optimization.

PAGE 8 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Compiler and Interpreter are two different ways to translate a program from programming or scripting language to machine language. 

A compiler takes entire program and converts it into object code which is typically stored in a file. 
The object code is also referred as binary code and can be directly executed by the machine after linking. 
Examples of compiled programming languages are C and C++. 

An Interpreter directly executes instructions written in a programming or scripting language without 
previously converting them to an object code or machine code. Examples of interpreted languages are Perl, Python and Matlab. 

Following are some interesting facts about interpreters and compilers. 


1) Both compilers and interpreters convert source code (text files) into tokens, both may generate a parse tree, and both may generate immediate instructions. The basic difference is that a compiler system, including a (built in or separate) linker, generates a stand alone machine code program, while an interpreter system instead performs the actions described by the high level program. 
2) Once a program is compiled, its source code is not useful for running the code. For interpreted programs, the source code is needed to run the program every time. 
3) In general, interpreted programs run slower than the compiled programs. 
4) Java programs are first compiled to an intermediate form, then interpreted by the interpreter.

PAGE 9 ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Java Virtual Machine (JVM) is used in the java runtime environment(JRE). The original JVM was conceived as a bytecode interpreter. This may come as a bit of a surprise because of performance problems. Many modern languages are meant to be compiled into CPU-specific, executable code. The fact that the JVM executes a Java program, however, helps address the major issues associated with web-based applications.



The fact that the JVM executes a Java program also helps to make it stable. Since the JVM is in charge, program execution is controlled by it. Therefore, it is possible for the JVM to build a limited execution area called a sandbox that contains the software, preventing the system from getting unlimited access. Protection is also improved by some limitations in the Java language that exists. Java’s JVM architecture includes a class loader, execution engine, memory field, etc.

In order to understand differences, let’s dig down to the components by illustrating the working of JVM alongside. 


1) ClassLoader: The class loader has the purpose of loading class files. It helps accomplish three main functions: Loading, Initialization, and Linking.
2) JVM language Stacks: Java memory stores local variables, and partial results of a computation. Each thread has its own JVM stack, created as the thread is created. When the method is invoked, a new frame is created, and then removed.
3) Method Area: JVM Method Area specializes in storing the metadata and code-behind files for Java applications.
4) PC Registers: The Java Virtual Machine Instruction address currently being executed is saved by PC registers. Each thread in Java has its own separate PC register.
5) Heap: In a heap are saved all objects, arrays, and instance variables. This memory is shared between several threads.
6) Execution Engine: It is a form of software used for the testing of software, hardware, or complete systems. The test execution engine never carries any information concerning the product being tested.
Native Method Libraries which are the Executing Engine needs Native Libraries (C, C++) and the native method interface which is a framework for programming is the Native Method Interface. This enables the Java code that runs in a JVM to call libraries and native applications. Also, the native method stacks have a native code command depending on the native library. It assigns storage to native heaps or uses any stack type.

    {JDK(javac,jar,debugging tools,API)->{JRE(java,javaw,Libraries)}->{JVM}->{JIT compiler}}

Just In Time(JIT) compiler

While Java was developed as an interpreted language, in order to improve performance, there is nothing about Java that prevents bytecode compilation into native code on the fly. For that reason, not long after Java’s initial release, the HotSpot JVM was released. A just-in-time (JIT) bytecode compiler is included in HotSpot.
A Just In Time(JIT) compiler is part of the JVM and on a piece-by-piece demand basis, selected portions of bytecode are compiled into executable code in real-time. That is, as is necessary during execution, a JIT compiler compiles code. In addition, not all bytecode sequences are compiled, only those that will benefit from
the compilation. The just-in-time method, however, still yields a major boost in inefficiency. The portability and safety function still exists even though dynamic compilation is applied to bytecode since the JVM is still in control of the execution environment.

In order to understand differences, let’s dig down to the components by illustrating the working of JIT alongside.

Interpreting the bytecode, the standard implementation of the JVM slows the execution of the programs. JIT compilers interact with JVM at runtime to improve performance and compile appropriate bytecode sequences into native machine code.

Hardware is interpreting the code instead of JVM (Java Virtual Machine). This can lead to performance gains in the speed of execution. This can be done per-file, per-function, or maybe on any arbitrary code fragment; the code is often compiled when it’s close to being executed (hence the name “just-in-time”), and then cached and reused later without having to be recompiled. It performs many optimizations: data analysis, translation from stack operations to registry operations, reduction of memory access by registry allocation, elimination of common sub-expressions.

Hence, from the above knowledge, we landed on the conclusive differences between them as mentioned in the table below:

                                JVM                                                                         JIT

                JVM stands for Java Virtual Machine.	                                    JIT stands for Just-in-time compilation.

        JVM was introduced for managing system memory                               JIT was invented to improve the performance of JVM after many years of its initial release.
        and providing a transportable execution environment
                      for Java-based applications

        JVM consists of many other components like stack area, heap area, etc.	                JIT is one of the components of JVM.

            JVM compiles complete byte code to machine code.	                        JIT compiles only the reusable byte code to machine code.

            JVM provides platform independence.	                                                    JIT improves the performance of JVM.

PAGE 10 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DIFFERENCE BETWEEN BYTE CODE & MACHINE CODE :-

Byte code is an intermediate code between the source code and machine code. It is a low-level code that is the result of the compilation of a source code which is written in a high-level language. It is processed by a virtual machine like Java Virtual Machine (JVM).
Byte code is a non-runnable code after it is translated by an interpreter into machine code then it is understandable by the machine. It is compiled to run on JVM, any system having JVM can run it irrespective of their operating system. That’s why Java is platform-independent. Byte code is referred to as a Portable code.

Machine Code:
Machine code is a set of instructions that is directly machine-understandable and it is processed by the Central Processing Unit (CPU). Machine code is in binary (0’s and 1’s) format which is completely different from the byte code and source code. It is regarded as the most lowest-level representation of the source code. Machine code is obtained after compilation or interpretation. It is also called machine language.


The below figure illustrates the example of how Java source code is converted to Byte code and then to machine code :

    {Java Program}  --->  {Java Compiler}  --->  {Java Byte Code}  --->  {Java Interpreter}  --->  {Machine COde}

Difference between Byte Code and Machine Code:

S.NO.                                                               Byte Code                                                          Machine Code

 01.	                Byte Code consisting of binary, hexadecimal, macro instructions like (new, add, swap, etc)          Machine code consisting of binary
                        and it is not directly understandable by the CPU. It is designed for efficient execution by         instructions that are directly understandable by the CPU.
                                        software such as a virtual machine.intermediate-level

02. 	                Byte code is considered as the intermediate-level code.	                                            Machine Code is considered as the low-level code.

03.	                    Byte code is a non-runnable code generated after compilation of source code and it relies on an     Machine code is a set of instructions in machine language or in binary format and it is directly executed by CPU.
                                            interpreter to get executed.

04.	                    Byte code is executed by the virtual machine then the Central Processing Unit.	                    Machine code is not executed by a virtual machine it is directly executed by CPU.

05. 	                Byte code is less specific towards machine than the machine code.	                                Machine code is more specific towards machine than the byte code.

06.	                    It is platform-independent as it is dependent on the virtual machine and the system having a        It is not platform independent because the object code of one platform can not be run on the same Operating System.
                        virtual machine can be executed irrespective of the platform.	                                    Object varies depending upon system architecture and native instructions associated with the machine.

07.	                    All the source code need not be converted into byte code for execution by CPU. Some source
                        code written by any specific high-level language is converted into byte code then byte code         All the source code must be converted into machine code before it is executed by the CPU.
                                            to object code for execution by CPU.

PAGE 11 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ClassLoader in Java :-

The Java ClassLoader is a part of the Java Runtime Environment that dynamically loads Java classes into the Java Virtual Machine. The Java run time system does not need to know about files and file systems because of classloaders. Java classes aren’t loaded into memory all at once, but when required by an application. At this point, the Java ClassLoader is called by the JRE and these ClassLoaders load classes into memory dynamically.

Types of ClassLoaders in Java

Not all classes are loaded by a single ClassLoader. Depending on the type of class and the path of class, the ClassLoader that loads that particular class is decided. To know the ClassLoader that loads a class the getClassLoader() method is used. All classes are loaded based on their names and if any of these classes are not found then it returns a NoClassDefFoundError or ClassNotFoundException. A Java Classloader is of three types:

1) BootStrap ClassLoader: A Bootstrap Classloader is a Machine code which kickstarts the operation when the JVM calls it. It is not a java class. Its job is to load the first pure Java ClassLoader. Bootstrap ClassLoader loads classes from the location rt.jar. Bootstrap ClassLoader doesn’t have any parent ClassLoaders. It is also called as the Primordial ClassLoader.
2) Extension ClassLoader: The Extension ClassLoader is a child of Bootstrap ClassLoader and loads the extensions of core java classes from the respective JDK Extension library. It loads files from jre/lib/ext directory or any other directory pointed by the system property java.ext.dirs.
3) System ClassLoader: An Application ClassLoader is also known as a System ClassLoader. It loads the Application type classes found in the environment variable CLASSPATH, -classpath or -cp command line option. The Application ClassLoader is a child class of Extension ClassLoader.

Note: The ClassLoader Delegation Hierarchy Model always functions in the order Application ClassLoader->Extension ClassLoader->Bootstrap ClassLoader. The Bootstrap ClassLoader is always given the higher priority, next is Extension ClassLoader and then Application ClassLoader. 

            {Bootstrap Class Loader} ------> {Find Class} --------> Class is Loaded By Bootstrap Class Loader
              ^                |
Load Class    |                |    Load Class
              |                |
            {Extension Class Loader} ------> {Find Class} ---------> Class is Loaded by Extension Class Loader
              ^                |
Load Class    |                |    Load Class
              |                |
            {Application Class Loader} <------{Request to Load a Class}


Principles of functionality of a Java ClassLoader

Principles of functionality are the set of rules or features on which a Java ClassLoader works. There are three principles of functionality, they are:

1) Delegation Model: The Java Virtual Machine and the Java ClassLoader use an algorithm called the Delegation Hierarchy Algorithm to Load the classes into the Java file. The ClassLoader works based on a set of operations given by the delegation model. They are:
        ClassLoader always follows the Delegation Hierarchy Principle.
        Whenever JVM comes across a class, it checks whether that class is already loaded or not.
        If the Class is already loaded in the method area then the JVM proceeds with execution.
        If the class is not present in the method area then the JVM asks the Java ClassLoader Sub-System to load that particular class, then ClassLoader sub-system hands over the control to Application ClassLoader.
        Application ClassLoader then delegates the request to Extension ClassLoader and the Extension ClassLoader in turn delegates the request to Bootstrap ClassLoader.
        Bootstrap ClassLoader will search in the Bootstrap classpath(JDK/JRE/LIB). If the class is available then it is loaded, if not the request is delegated to Extension ClassLoader.
        Extension ClassLoader searches for the class in the Extension Classpath(JDK/JRE/LIB/EXT). If the class is available then it is loaded, if not the request is delegated to the Application ClassLoader.
        Application ClassLoader searches for the class in the Application Classpath. If the class is available then it is loaded, if not then a ClassNotFoundException exception is generated.
2) Visibility Principle: The Visibility Principle states that a class loaded by a parent ClassLoader is visible to the child ClassLoaders but a class loaded by a child ClassLoader is not visible to the parent ClassLoaders. Suppose a class GEEKS.class has been loaded by the Extension ClassLoader, then that class is only visible to the Extension ClassLoader and Application ClassLoader but not to the Bootstrap ClassLoader. If that class is again tried to load using Bootstrap ClassLoader it gives an exception java.lang.ClassNotFoundException.
3) Uniqueness Property: The Uniquesness Property ensures that the classes are unique and there is no repetition of classes. This also ensures that the classes loaded by parent classloaders are not loaded by the child classloaders. If the parent class loader isn’t able to find the class, only then the current instance would attempt to do so itself.

Methods of Java.lang.ClassLoader :-
After the JVM requests for the class, a few steps are to be followed in order to load a class. The Classes are loaded as per the delegation model but there are a few important Methods or Functions that play a vital role in loading a Class.

1) loadClass(String name, boolean resolve): This method is used to load the classes which are referenced by the JVM. It takes the name of the class as a parameter. This is of type loadClass(String, boolean).
2) defineClass(): The defineClass() method is a final method and cannot be overridden. This method is used to define a array of bytes as an instance of class. If the class is invalid then it throws ClassFormatError.
3) findClass(String name): This method is used to find a specified class. This method only finds but doesn’t load the class.
4) findLoadedClass(String name): This method is used to verify whether the Class referenced by the JVM was previously loaded or not.
5) Class.forName(String name, boolean initialize, ClassLoader loader): This method is used to load the class as well as initialize the class. This method also gives the option to choose any one of the ClassLoaders. If the ClassLoader parameter is NULL then Bootstrap ClassLoader is used.
6) Example: The following code is executed before a class is loaded:

protected synchronized Class<?>
loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    Class c = findLoadedClass(name);
    try {
        if (c == NULL) {
            if (parent != NULL) {
                c = parent.loadClass(name, false);
            }
            else {
                c = findBootstrapClass0(name);
            }
        }
        catch (ClassNotFoundException e)
        {
            System.out.println(e);
        }
    }
}
Note: If a class has already been loaded, it returns it. Otherwise, it delegates the search for the new class to the parent class loader. If the parent class loader doesn’t find the class, loadClass() calls the method findClass() to find and load the class. The findClass() method searches for the class in the current ClassLoader if the class wasn’t found by the parent ClassLoader.

PAGE 12 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Byte Code Verifier & Interpreter :-

The JVM puts code through Byte Code Verifier that checks the format & checks for an illegal code. Illegal Code for Example, Code that violates access 
rights on objects or violates the implementation of Pointers.
The Byte Code verifier ensures that code address to JVM specification and does not violates system integrity

        {RUTIME}--------->{[Class Loader]--->[Byte-Code Verifier]--->[Interpreter]--->[Runtime]---->[Hardware]}

Interpreter :- At runtime the Byte Code is Loaded checked and run by interpreter. The Interpreter has following 2 Functions

1) Execute Byte Code
2) Make Appropriate calles to underlying Hardware

Compile :-                                                                                                            Runtime :-

|Compile ------Save------> ------Javac------>|  ---------{Load from Hard Disk, Network or Other Sources}---------->   {RUTIME}--------->{[Class Loader]--->[Byte-Code Verifier]--->[Interpreter]--->[Runtime]---->[Hardware]}
|           Example.java     Example.class   |

PAGE 13 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

To Understand Interaction Between JDK & JRE consider following diagram :-

    {Java Source Code}  ------->  {Jav Development Kit(JDK) [Java Compiler]}  -------->  {Java Byte Code}  ------->  {[Just-in-Time Compiler(JIT)] Java Virtual Machine(JVM)}  ---------->  {Java Runtime Environment(JRE)}
                                                                                                                     --------------------------------------------------------
                                                                                                                     {                Hardware Platform                     }

PAGE 14 --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

How is Java Platform Independent :-

The meaning of platform-independent is that the java compiled code(byte code) can run on all operating systems.
A program is written in a language that is a human-readable language.
It may contain words, phrases, etc which the machine does not understand.
For the source code to be understood by the machine, it needs to be in a
language understood by machines, typically a machine-level language. So,
here comes the role of a compiler. The compiler converts the high-level
language (human language) into a format understood by the machines.
Therefore, a compiler is a program that translates the source code for
another program from a programming language into executable code.
This executable code may be a sequence of machine instructions that can be executed by the CPU directly, or it may be an intermediate representation that is interpreted by a virtual machine. This intermediate representation in Java is the Java Byte Code.

Step by step Execution of Java Program:

-> Whenever, a program is written in JAVA, the javac compiles it.
-> The result of the JAVA compiler is the .class file or the bytecode and not the machine native code (unlike C compiler).
-> The bytecode generated is a non-executable code and needs an interpreter to execute on a machine. This interpreter is the JVM and thus the Bytecode is executed by the JVM.
-> And finally program runs to give the desired output.

    {Java Source Code} -----> {Java Compiler} -----> {Java ByteCode}
                                                           / \
                                                          /   \
                                                         /     \
                                                        /       \
                                                       /         \
                                        Java Interpreter        Byte Code Compiler
                                                                        |
                                                                        |
                                                                        |
                                                                        |
                                                                   Machine Code

In case of C or C++ (language that are not platform independent), the compiler generates an .exe file which is OS dependent. When we try to run this .exe file on another OS it does not run, since it is OS dependent and hence is not compatible with the other OS.

Java is platform-independent but JVM is platform dependent


In Java, the main point here is that the JVM depends on the operating system – so if you are running Mac OS X you will have a different JVM than if you are running Windows or some other operating system.
This fact can be verified by trying to download the JVM for your particular machine – when trying to download it, you will be given a list of JVMs corresponding to different operating systems, and you will
obviously pick whichever JVM is targeted for the operating system that you are running. So we can conclude that JVM is platform-dependent and it is the reason why Java is able to become “Platform Independent”.

Important Points:
1) In the case of Java, it is the magic of Bytecode that makes it platform independent.
2) This adds to an important feature in the JAVA language termed as portability. Every system has its own JVM which gets installed automatically when the jdk software is installed. For every operating system separate JVM is available which is capable to read the .class file or byte code.
3) An important point to be noted is that while JAVA is platform-independent language, the JVM is platform-dependent. Different JVM is designed for different OS and byte code is able to run on different OS.
